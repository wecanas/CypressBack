import { Expression, ParameterTypeRegistry } from "@cucumber/cucumber-expressions";
import parse from "@cucumber/tag-expressions";
import type { IdGenerator } from "@cucumber/messages";
import DataTable from "./data_table";
import { CypressCucumberError } from "./helpers/error";
import { ICaseHookBody, ICaseHookOptions, ICaseHookParameter, IParameterTypeDefinition, IRunHookBody, IRunHookOptions, IStepDefinitionBody, IStepHookBody, IStepHookParameter } from "./public-member-types";
import { Position } from "./helpers/source-map";
export interface IStepDefinition<T extends unknown[], C extends Mocha.Context> {
    id: string;
    expression: Expression;
    implementation: IStepDefinitionBody<T, C>;
    position?: Position;
}
export declare class MissingDefinitionError extends CypressCucumberError {
}
export declare class MultipleDefinitionsError extends CypressCucumberError {
}
export type RunHookKeyword = "BeforeAll" | "AfterAll";
export type CaseHookKeyword = "Before" | "After";
export type StepHookKeyword = "BeforeStep" | "AfterStep";
type Node = ReturnType<typeof parse>;
export declare const DEFAULT_HOOK_ORDER = 10000;
export interface IRunHook<C extends Mocha.Context> {
    implementation: IRunHookBody<C>;
    keyword: RunHookKeyword;
    order: number;
    position?: Position;
}
export interface ICaseHook<C extends Mocha.Context> {
    id: string;
    node: Node;
    implementation: ICaseHookBody<C>;
    keyword: CaseHookKeyword;
    order: number;
    position?: Position;
    tags?: string;
    name?: string;
}
export interface IStepHook<C extends Mocha.Context> {
    node: Node;
    implementation: IStepHookBody<C>;
    keyword: StepHookKeyword;
    order: number;
    position?: Position;
    tags?: string;
    name?: string;
}
export declare class Registry<C extends Mocha.Context, T extends unknown[]> {
    private experimentalSourceMap;
    parameterTypeRegistry: ParameterTypeRegistry;
    private preliminaryStepDefinitions;
    stepDefinitions: IStepDefinition<T, C>[];
    private preliminaryHooks;
    runHooks: IRunHook<C>[];
    caseHooks: ICaseHook<C>[];
    stepHooks: IStepHook<C>[];
    constructor(experimentalSourceMap?: boolean);
    finalize(newId: IdGenerator.NewId): void;
    defineStep(description: string | RegExp, implementation: IStepDefinitionBody<T, C>): void;
    defineParameterType<T, C extends Mocha.Context>({ name, regexp, transformer, }: IParameterTypeDefinition<T, C>): void;
    defineCaseHook(keyword: CaseHookKeyword, options: ICaseHookOptions, fn: ICaseHookBody<C>): void;
    defineBefore(options: ICaseHookOptions, fn: ICaseHookBody<C>): void;
    defineAfter(options: ICaseHookOptions, fn: ICaseHookBody<C>): void;
    defineStepHook(keyword: StepHookKeyword, options: ICaseHookOptions, fn: IStepHookBody<C>): void;
    defineBeforeStep(options: ICaseHookOptions, fn: IStepHookBody<C>): void;
    defineAfterStep(options: ICaseHookOptions, fn: IStepHookBody<C>): void;
    defineRunHook(keyword: RunHookKeyword, options: IRunHookOptions, fn: IRunHookBody<C>): void;
    defineBeforeAll(options: IRunHookOptions, fn: IRunHookBody<C>): void;
    defineAfterAll(options: IRunHookOptions, fn: IRunHookBody<C>): void;
    getMatchingStepDefinitions(text: string): IStepDefinition<T, C>[];
    resolveStepDefinition(text: string): IStepDefinition<T, C>;
    runStepDefinition(world: C, text: string, dryRun: boolean, argument?: DataTable | string): unknown;
    resolveCaseHooks(keyword: CaseHookKeyword, tags: string[]): ICaseHook<C>[];
    resolveBeforeHooks(tags: string[]): ICaseHook<C>[];
    resolveAfterHooks(tags: string[]): ICaseHook<C>[];
    runCaseHook(world: C, hook: ICaseHook<C>, options: ICaseHookParameter): void;
    resolveStepHooks(keyword: StepHookKeyword, tags: string[]): IStepHook<C>[];
    resolveBeforeStepHooks(tags: string[]): IStepHook<C>[];
    resolveAfterStepHooks(tags: string[]): IStepHook<C>[];
    runStepHook(world: C, hook: IStepHook<C>, options: IStepHookParameter): void;
    resolveRunHooks(keyword: RunHookKeyword): IRunHook<C>[];
    resolveBeforeAllHooks(): IRunHook<C>[];
    resolveAfterAllHooks(): IRunHook<C>[];
    runRunHook(world: C, hook: IRunHook<C>): void;
}
export declare function withRegistry<C extends Mocha.Context, T extends unknown[]>(experimentalSourceMap: boolean, fn: () => void): Registry<C, T>;
export declare function assignRegistry<C extends Mocha.Context, T extends unknown[]>(registry: Registry<C, T>): void;
export declare function freeRegistry(): void;
export declare function getRegistry<C extends Mocha.Context, T extends unknown[]>(): Registry<C, T>;
export {};
